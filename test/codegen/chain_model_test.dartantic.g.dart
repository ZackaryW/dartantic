// dart format width=80
// GENERATED BY DARTANTIC

part of 'chain_model_test.dart';

// **************************************************************************
// ModelGenerator
// **************************************************************************

const DttModelMeta _dtt_Address_fieldMeta = DttModelMeta(
  fields: {
    'street': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'city': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'country': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'postalCode': DttFieldMeta(
      type: 'String?',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
  },
);

mixin _$AddressMixin {
  static Map<String, dynamic> dttCreate({
    required String street,
    required String city,
    required String country,
    String? postalCode,
  }) {
    final values = <String, dynamic>{
      'street': street,
      'city': city,
      'country': country,
      'postalCode': postalCode,
    };
    final processedValues = dttPreprocess(values);
    dttValidate(processedValues);
    return dttPostprocess(processedValues);
  }

  static Map<String, dynamic> dttPreprocess(Map<String, dynamic> values) {
    // Preprocessing step - modify values before validation
    values['street'] = Address._dttpreprocess_street(values['street']);
    return values;
  }

  static void dttValidate(Map<String, dynamic> values) {
    if (values['street'] == null) {
      throw DttValidationError('street', 'street is required');
    }
    if (values['street'] != null && values['street'].length < 5) {
      throw DttValidationError(
        'street',
        'street must be at least 5 characters',
      );
    }
    if (values['city'] == null) {
      throw DttValidationError('city', 'city is required');
    }
    if (values['city'] != null && values['city'].length < 2) {
      throw DttValidationError('city', 'city must be at least 2 characters');
    }
    if (values['country'] == null) {
      throw DttValidationError('country', 'country is required');
    }
    if (values['country'] != null && values['country'].length < 2) {
      throw DttValidationError(
        'country',
        'country must be at least 2 characters',
      );
    }
    if (values['postalCode'] != null &&
        !Address._dttvalidate_postalCode(values['postalCode'])) {
      throw DttValidationError(
        'postalCode',
        'postalCode failed custom validation',
      );
    }
  }

  static Map<String, dynamic> dttPostprocess(Map<String, dynamic> values) {
    // Postprocessing step - modify values after validation
    // No postprocessing methods found
    return values;
  }

  static Map<String, dynamic> dttFromMap(Map<String, dynamic> map) {
    // Process and validate map data (including nested models)
    final processedMap = <String, dynamic>{
      'street': map['street'],
      'city': map['city'],
      'country': map['country'],
      'postalCode': map['postalCode'],
    };
    // Apply preprocessing, validation, and postprocessing to the processed map
    final preprocessed = dttPreprocess(processedMap);
    dttValidate(preprocessed);
    return dttPostprocess(preprocessed);
  }

  static Map<String, dynamic> dttToMap(Address obj) {
    // Convert object instance to a map
    return {
      'street': obj.street,
      'city': obj.city,
      'country': obj.country,
      'postalCode': obj.postalCode,
    };
  }
}

const DttModelMeta _dtt_ContactInfo_fieldMeta = DttModelMeta(
  fields: {
    'email': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'phone': DttFieldMeta(
      type: 'String?',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'address': DttFieldMeta(
      type: 'Address',
      isFinal: true,
      isLate: false,
      subModel: 'Address',
    ),
  },
);

mixin _$ContactInfoMixin {
  static Map<String, dynamic> dttCreate({
    required String email,
    String? phone,
    required Address address,
  }) {
    final values = <String, dynamic>{
      'email': email,
      'phone': phone,
      'address': address,
    };
    final processedValues = dttPreprocess(values);
    dttValidate(processedValues);
    return dttPostprocess(processedValues);
  }

  static Map<String, dynamic> dttPreprocess(Map<String, dynamic> values) {
    // Preprocessing step - modify values before validation
    values['phone'] = ContactInfo._dttpreprocess_phone(values['phone']);
    values['email'] = ContactInfo._dttpreprocess_email(values['email']);
    return values;
  }

  static void dttValidate(Map<String, dynamic> values) {
    if (values['email'] == null) {
      throw DttValidationError('email', 'email is required');
    }
    if (values['email'] != null && !validateEmailFormat(values['email'])) {
      throw DttValidationError('email', 'email failed custom validation');
    }
    if (values['phone'] != null && values['phone'].length < 10) {
      throw DttValidationError('phone', 'phone must be at least 10 characters');
    }
    if (values['phone'] != null &&
        !ContactInfo._dttvalidate_phone(values['phone'])) {
      throw DttValidationError('phone', 'phone failed custom validation');
    }
  }

  static Map<String, dynamic> dttPostprocess(Map<String, dynamic> values) {
    // Postprocessing step - modify values after validation
    // No postprocessing methods found
    return values;
  }

  static Map<String, dynamic> dttFromMap(Map<String, dynamic> map) {
    // Process and validate map data (including nested models)
    final processedMap = <String, dynamic>{
      'email': map['email'],
      'phone': map['phone'],
      'address': _$AddressMixin.dttFromMap(
        map['address'] as Map<String, dynamic>,
      ),
    };
    // Apply preprocessing, validation, and postprocessing to the processed map
    final preprocessed = dttPreprocess(processedMap);
    dttValidate(preprocessed);
    return dttPostprocess(preprocessed);
  }

  static Map<String, dynamic> dttToMap(ContactInfo obj) {
    // Convert object instance to a map
    return {
      'email': obj.email,
      'phone': obj.phone,
      'address': _$AddressMixin.dttToMap(obj.address),
    };
  }
}

const DttModelMeta _dtt_Employee_fieldMeta = DttModelMeta(
  fields: {
    'name': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'employeeId': DttFieldMeta(
      type: 'int',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'contact': DttFieldMeta(
      type: 'ContactInfo',
      isFinal: true,
      isLate: false,
      subModel: 'ContactInfo',
    ),
    'manager': DttFieldMeta(
      type: 'Employee?',
      isFinal: true,
      isLate: false,
      subModel: 'Employee',
    ),
  },
);

mixin _$EmployeeMixin {
  static Map<String, dynamic> dttCreate({
    required String name,
    required int employeeId,
    required ContactInfo contact,
    Employee? manager,
  }) {
    final values = <String, dynamic>{
      'name': name,
      'employeeId': employeeId,
      'contact': contact,
      'manager': manager,
    };
    final processedValues = dttPreprocess(values);
    dttValidate(processedValues);
    return dttPostprocess(processedValues);
  }

  static Map<String, dynamic> dttPreprocess(Map<String, dynamic> values) {
    // Preprocessing step - modify values before validation
    values['name'] = Employee._dttpreprocess_name(values['name']);
    return values;
  }

  static void dttValidate(Map<String, dynamic> values) {
    if (values['name'] == null) {
      throw DttValidationError('name', 'name is required');
    }
    if (values['name'] != null && values['name'].length < 2) {
      throw DttValidationError('name', 'name must be at least 2 characters');
    }
    if (values['employeeId'] == null) {
      throw DttValidationError('employeeId', 'employeeId is required');
    }
    if (values['employeeId'] != null &&
        !Employee._dttvalidate_employeeId(values['employeeId'])) {
      throw DttValidationError(
        'employeeId',
        'employeeId failed custom validation',
      );
    }
  }

  static Map<String, dynamic> dttPostprocess(Map<String, dynamic> values) {
    // Postprocessing step - modify values after validation
    // No postprocessing methods found
    return values;
  }

  static Map<String, dynamic> dttFromMap(Map<String, dynamic> map) {
    // Process and validate map data (including nested models)
    final processedMap = <String, dynamic>{
      'name': map['name'],
      'employeeId': map['employeeId'],
      'contact': _$ContactInfoMixin.dttFromMap(
        map['contact'] as Map<String, dynamic>,
      ),
      'manager':
          map['manager'] != null
              ? _$EmployeeMixin.dttFromMap(
                map['manager'] as Map<String, dynamic>,
              )
              : null,
    };
    // Apply preprocessing, validation, and postprocessing to the processed map
    final preprocessed = dttPreprocess(processedMap);
    dttValidate(preprocessed);
    return dttPostprocess(preprocessed);
  }

  static Map<String, dynamic> dttToMap(Employee obj) {
    // Convert object instance to a map
    return {
      'name': obj.name,
      'employeeId': obj.employeeId,
      'contact': _$ContactInfoMixin.dttToMap(obj.contact),
      'manager':
          obj.manager != null ? _$EmployeeMixin.dttToMap(obj.manager!) : null,
    };
  }
}
