// GENERATED BY DARTANTIC BLOC GENERATOR

part of 'user_bloc_test.dart';

// **************************************************************************
// BlocGenerator
// **************************************************************************

// Standalone bloc implementation (no external dependencies)
class _Equatable {
  const _Equatable();
  @override
  List<Object?> get props {
    return [];
  }
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other.runtimeType != runtimeType) return false;
    final otherEquatable = other as _Equatable;
    return _listEquals(props, otherEquatable.props);
  }
  @override
  int get hashCode {
    return _listHashCode(props);
  }
  static bool _listEquals(List<Object?> a, List<Object?> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
  static int _listHashCode(List<Object?> list) {
    int hash = 0;
    for (final item in list) {
      hash = hash ^ (item?.hashCode ?? 0);
    }
    return hash;
  }
}
class _Cubit<State> {
  State _state;
  final List<void Function(State)> _listeners = [];
  _Cubit(this._state) {
  }
  State get state {
    return _state;
  }
  void emit(State newState) {
    _state = newState;
    for (final listener in _listeners) {
      listener(newState);
    }
  }
  void listen(void Function(State) listener) {
    _listeners.add(listener);
  }
  void dispose() {
    _listeners.clear();
  }
}

// State Classes
class UserBlocState extends _Equatable {
  const UserBlocState();
  @override
  List<Object?> get props {
    return [];
  }
  static UserBlocState initial() {
    return UserBlocInitial();
  }
  static UserBlocState loading() {
    return UserBlocLoading();
  }
  static UserBlocState success(Map<String, dynamic> data) {
    return UserBlocData.fromValidated(data);
  }
  static UserBlocState error(String message) {
    return UserBlocError(message);
  }
}
class UserBlocData extends UserBlocState {
  final String name;
  final int age;
  final String email;
  final String password;
  final bool isActive;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final String? nickname;
  const UserBlocData({required this.name, required this.age, required this.email, required this.password, required this.isActive, required this.createdAt, this.updatedAt, this.nickname});
  static UserBlocData fromValidated(Map<String, dynamic> data) {
    return UserBlocData(
      name: data['name'] as String,
      age: data['age'] as int,
      email: data['email'] as String,
      password: data['password'] as String,
      isActive: data['isActive'] as bool,
      createdAt: data['createdAt'] as DateTime,
      updatedAt: data['updatedAt'] as DateTime?,
      nickname: data['nickname'] as String?,
    );
  }
  UserBlocData copyWith({String? name, int? age, String? email, String? password, bool? isActive, DateTime? createdAt, DateTime? updatedAt, String? nickname}) {
    return UserBlocData(
      name: name ?? this.name,
      age: age ?? this.age,
      email: email ?? this.email,
      password: password ?? this.password,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      nickname: nickname ?? this.nickname,
    );
  }
  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'age': age,
      'email': email,
      'password': password,
      'isActive': isActive,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'nickname': nickname,
    };
  }
  @override
  List<Object?> get props {
    return [name, age, email, password, isActive, createdAt, updatedAt, nickname];
  }
  bool get isValid {
    try {
      _$UserBlocMixin.dttValidate(toMap());
      return true;
    } catch (e) {
      return false;
    }
  }
}
class UserBlocLoading extends UserBlocState {
  const UserBlocLoading();
}
class UserBlocError extends UserBlocState {
  final String message;
  const UserBlocError(this.message);
  @override
  List<Object?> get props {
    return [message];
  }
}
class UserBlocInitial extends UserBlocState {
  const UserBlocInitial();
}

// Event Classes
class UserBlocEvent extends _Equatable {
  const UserBlocEvent();
  @override
  List<Object?> get props {
    return [];
  }
}
class UserBlocUpdateName extends UserBlocEvent {
  final String name;
  const UserBlocUpdateName(this.name);
  @override
  List<Object?> get props {
    return [name];
  }
}
class UserBlocUpdateAge extends UserBlocEvent {
  final int age;
  const UserBlocUpdateAge(this.age);
  @override
  List<Object?> get props {
    return [age];
  }
}
class UserBlocUpdateEmail extends UserBlocEvent {
  final String email;
  const UserBlocUpdateEmail(this.email);
  @override
  List<Object?> get props {
    return [email];
  }
}
class UserBlocUpdatePassword extends UserBlocEvent {
  final String password;
  const UserBlocUpdatePassword(this.password);
  @override
  List<Object?> get props {
    return [password];
  }
}
class UserBlocUpdateIsActive extends UserBlocEvent {
  final bool isActive;
  const UserBlocUpdateIsActive(this.isActive);
  @override
  List<Object?> get props {
    return [isActive];
  }
}
class UserBlocUpdateCreatedAt extends UserBlocEvent {
  final DateTime createdAt;
  const UserBlocUpdateCreatedAt(this.createdAt);
  @override
  List<Object?> get props {
    return [createdAt];
  }
}
class UserBlocUpdateUpdatedAt extends UserBlocEvent {
  final DateTime? updatedAt;
  const UserBlocUpdateUpdatedAt(this.updatedAt);
  @override
  List<Object?> get props {
    return [updatedAt];
  }
}
class UserBlocUpdateNickname extends UserBlocEvent {
  final String? nickname;
  const UserBlocUpdateNickname(this.nickname);
  @override
  List<Object?> get props {
    return [nickname];
  }
}
class UserBlocLoad extends UserBlocEvent {
  final Map<String, dynamic>? data;
  const UserBlocLoad([this.data]);
  @override
  List<Object?> get props {
    return [data];
  }
}
class UserBlocSave extends UserBlocEvent {
  const UserBlocSave();
  @override
  List<Object?> get props {
    return [];
  }
}
class UserBlocReset extends UserBlocEvent {
  const UserBlocReset();
  @override
  List<Object?> get props {
    return [];
  }
}
class UserBlocValidate extends UserBlocEvent {
  const UserBlocValidate();
  @override
  List<Object?> get props {
    return [];
  }
}

// Cubit Class
class UserBlocCubit extends _Cubit<UserBlocState> {
  UserBlocCubit() : super(UserBlocState.initial()) {
  }
  void updateName(String name) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(name: name);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'name': name,
              'age': 0,
              'email': '',
              'password': '',
              'isActive': false,
              'createdAt': DateTime.now(),
              'updatedAt': null,
              'nickname': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void updateAge(int age) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(age: age);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'age': age,
              'name': '',
              'email': '',
              'password': '',
              'isActive': false,
              'createdAt': DateTime.now(),
              'updatedAt': null,
              'nickname': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void updateEmail(String email) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(email: email);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'email': email,
              'name': '',
              'age': 0,
              'password': '',
              'isActive': false,
              'createdAt': DateTime.now(),
              'updatedAt': null,
              'nickname': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void updatePassword(String password) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(password: password);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'password': password,
              'name': '',
              'age': 0,
              'email': '',
              'isActive': false,
              'createdAt': DateTime.now(),
              'updatedAt': null,
              'nickname': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void updateIsActive(bool isActive) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(isActive: isActive);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'isActive': isActive,
              'name': '',
              'age': 0,
              'email': '',
              'password': '',
              'createdAt': DateTime.now(),
              'updatedAt': null,
              'nickname': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void updateCreatedAt(DateTime createdAt) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(createdAt: createdAt);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'createdAt': createdAt,
              'name': '',
              'age': 0,
              'email': '',
              'password': '',
              'isActive': false,
              'updatedAt': null,
              'nickname': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void updateUpdatedAt(DateTime? updatedAt) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(updatedAt: updatedAt);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'updatedAt': updatedAt,
              'name': '',
              'age': 0,
              'email': '',
              'password': '',
              'isActive': false,
              'createdAt': DateTime.now(),
              'nickname': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void updateNickname(String? nickname) {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      final updatedData = currentData.copyWith(nickname: nickname);
      emit(updatedData);
    } else {
      try {
        final data = <String, dynamic>{
          'nickname': nickname,
              'name': '',
              'age': 0,
              'email': '',
              'password': '',
              'isActive': false,
              'createdAt': DateTime.now(),
              'updatedAt': null,
        };
        final validatedData = _$UserBlocMixin.dttFromMap(data);
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void loadData(Map<String, dynamic> data) {
    emit(UserBlocState.loading());
    try {
      final validatedData = _$UserBlocMixin.dttFromMap(data);
      emit(UserBlocState.success(validatedData));
    } catch (e) {
      emit(UserBlocState.error(e.toString()));
    }
  }
  void saveData() {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      try {
        final validatedData = _$UserBlocMixin.dttCreate(
          name: currentData.name,
          age: currentData.age,
          email: currentData.email,
          password: currentData.password,
          isActive: currentData.isActive,
          createdAt: currentData.createdAt,
          updatedAt: currentData.updatedAt,
          nickname: currentData.nickname,
        );
        emit(UserBlocState.success(validatedData));
      } catch (e) {
        emit(UserBlocState.error(e.toString()));
      }
    }
  }
  void reset() {
    emit(UserBlocState.initial());
  }
  void validate() {
    if (state is UserBlocData) {
      final currentData = state as UserBlocData;
      if (currentData.isValid) {
        emit(UserBlocState.success(currentData.toMap()));
      } else {
        emit(UserBlocState.error("Validation failed"));
      }
    }
  }
  bool isValid() {
    if (state is UserBlocData) {
      return (state as UserBlocData).isValid;
    }
    return false;
  }
  Map<String, dynamic>? currentDataMap() {
    if (state is UserBlocData) {
      return (state as UserBlocData).toMap();
    }
    return null;
  }
}
