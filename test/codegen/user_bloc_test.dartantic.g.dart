// dart format width=80
// GENERATED BY DARTANTIC

part of 'user_bloc_test.dart';

// **************************************************************************
// ModelGenerator
// **************************************************************************

final DttModelMeta _dtt_UserBloc_fieldMeta = DttModelMeta(
  fields: {
    'name': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'age': DttFieldMeta(
      type: 'int',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'email': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'password': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'isActive': DttFieldMeta(
      type: 'bool',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'createdAt': DttFieldMeta(
      type: 'DateTime',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'updatedAt': DttFieldMeta(
      type: 'DateTime?',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'nickname': DttFieldMeta(
      type: 'String?',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
  },
);

mixin _$UserBlocMixin {
  static Map<String, dynamic> dttCreate({
    required String name,
    required int age,
    required String email,
    required String password,
    required bool isActive,
    required DateTime createdAt,
    DateTime? updatedAt,
    String? nickname,
  }) {
    final values = <String, dynamic>{
      'name': name,
      'age': age,
      'email': email,
      'password': password,
      'isActive': isActive,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'nickname': nickname,
    };
    final processedValues = dttPreprocess(values);
    dttValidate(processedValues);
    return dttPostprocess(processedValues);
  }

  static Map<String, dynamic> dttPreprocess(Map<String, dynamic> values) {
    // Preprocessing step - modify values before validation
    values['email'] = UserBloc._dttpreprocess_email(values['email']);
    values['password'] = UserBloc._dttpreprocess_password(values['password']);
    return values;
  }

  static void dttValidate(Map<String, dynamic> values) {
    if (values['name'] != null && values['name'].length < 2) {
      throw DttValidationError('name', 'name must be at least 2 characters');
    }
    if (values['age'] == null) {
      throw DttValidationError('age', 'age is required');
    }
    if (values['email'] != null && !validateEmailFormat(values['email'])) {
      throw DttValidationError('email', 'email failed custom validation');
    }
    if (values['email'] != null && values['email'].length < 5) {
      throw DttValidationError('email', 'email must be at least 5 characters');
    }
    if (values['email'] != null && values['email'].length > 50) {
      throw DttValidationError('email', 'email must be at most 50 characters');
    }
    if (values['password'] != null &&
        !validateStrongPassword(values['password'])) {
      throw DttValidationError('password', 'password failed custom validation');
    }
    if (values['password'] != null && values['password'].length < 8) {
      throw DttValidationError(
        'password',
        'password must be at least 8 characters',
      );
    }
    if (values['email'] != null &&
        !UserBloc._dttvalidate_email(values['email'], values)) {
      throw DttValidationError('email', 'email failed custom validation');
    }
    if (values['age'] != null && !UserBloc._dttvalidate_age(values['age'])) {
      throw DttValidationError('age', 'age failed custom validation');
    }
    if (values['name'] != null && !UserBloc._dttvalidate_name(values['name'])) {
      throw DttValidationError('name', 'name failed custom validation');
    }
  }

  static Map<String, dynamic> dttPostprocess(Map<String, dynamic> values) {
    // Postprocessing step - modify values after validation
    values['createdAt'] = UserBloc._dttpostprocess_createdAt(
      values['createdAt'],
    );
    values['isActive'] = UserBloc._dttpostprocess_isActive(values['isActive']);
    return values;
  }

  static Map<String, dynamic> dttFromMap(Map<String, dynamic> map) {
    // Process and validate map data (including nested models)
    final processedMap = <String, dynamic>{
      'name': map['name'],
      'age': map['age'],
      'email': map['email'],
      'password': map['password'],
      'isActive': map['isActive'],
      'createdAt': map['createdAt'],
      'updatedAt': map['updatedAt'],
      'nickname': map['nickname'],
    };
    // Apply preprocessing, validation, and postprocessing to the processed map
    final preprocessed = dttPreprocess(processedMap);
    dttValidate(preprocessed);
    return dttPostprocess(preprocessed);
  }

  static Map<String, dynamic> dttToMap(UserBloc obj) {
    // Convert object instance to a map
    return {
      'name': obj.name,
      'age': obj.age,
      'email': obj.email,
      'password': obj.password,
      'isActive': obj.isActive,
      'createdAt': obj.createdAt,
      'updatedAt': obj.updatedAt,
      'nickname': obj.nickname,
    };
  }
}
