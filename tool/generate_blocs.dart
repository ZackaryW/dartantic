#!/usr/bin/env dart

import 'dart:io';
import 'package:path/path.dart' as path;

/// Standalone bloc generator that runs after dartantic model generation
void main(List<String> args) async {
  print('üî• Dartantic Bloc Generator');
  print('üìÇ Scanning for @dttBloc annotated classes...');

  final workingDir = Directory.current;
  final libDir = Directory(path.join(workingDir.path, 'lib'));
  final testDir = Directory(path.join(workingDir.path, 'test'));

  var filesProcessed = 0;
  var blocsGenerated = 0;

  // Process lib directory
  if (await libDir.exists()) {
    final count = await _processDirectory(libDir);
    filesProcessed += count['files']!;
    blocsGenerated += count['blocs']!;
  }

  // Process test directory
  if (await testDir.exists()) {
    final count = await _processDirectory(testDir);
    filesProcessed += count['files']!;
    blocsGenerated += count['blocs']!;
  }

  print('‚úÖ Processed $filesProcessed files');
  print('üéØ Generated $blocsGenerated bloc files');
  print('üöÄ Bloc generation complete!');
}

Future<Map<String, int>> _processDirectory(Directory dir) async {
  var filesProcessed = 0;
  var blocsGenerated = 0;

  await for (final entity in dir.list(recursive: true)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      // Skip generated files
      if (entity.path.endsWith('.g.dart')) continue;

      filesProcessed++;
      if (await _processFile(entity)) blocsGenerated++;
    }
  }

  return {'files': filesProcessed, 'blocs': blocsGenerated};
}

Future<bool> _processFile(File file) async {
  try {
    final content = await file.readAsString();

    // Quick check for @dttBloc annotation
    if (!content.contains('@dttBloc')) {
      return false;
    }

    print('üîç Analyzing ${path.relative(file.path)}');

    // Check if corresponding .dartantic.g.dart file exists
    final dartanticFile = File(
      file.path.replaceAll('.dart', '.dartantic.g.dart'),
    );

    if (!await dartanticFile.exists()) {
      print('‚ö†Ô∏è  Skipping - no .dartantic.g.dart file found');
      print(
        '   Run "dart run build_runner build" first to generate model files',
      );
      return false;
    }

    // Read the metadata file
    final dartanticContent = await dartanticFile.readAsString();

    // Extract class name and fields from metadata
    final className = _extractClassName(dartanticContent);
    if (className == null) {
      print('‚ö†Ô∏è  Could not find class name in metadata');
      return false;
    }

    final fields = _extractFields(dartanticContent);
    if (fields.isEmpty) {
      print('‚ö†Ô∏è  Could not find fields in metadata');
      return false;
    }

    print('üî® Generating bloc for $className');

    // Generate bloc code
    final blocCode = _generateBlocCode(
      className,
      fields,
      path.basenameWithoutExtension(file.path),
    );

    // Write bloc file
    final blocFile = File(file.path.replaceAll('.dart', '.bloc.g.dart'));
    await blocFile.writeAsString(blocCode);

    print('‚úÖ Generated ${path.relative(blocFile.path)}');
    return true;
  } catch (e) {
    print('‚ùå Error processing ${file.path}: $e');
    return false;
  }
}

String? _extractClassName(String content) {
  final match = RegExp(r'_dtt_(\w+)_fieldMeta').firstMatch(content);
  return match?.group(1);
}

Map<String, String> _extractFields(String content) {
  final fields = <String, String>{};
  final fieldPattern = RegExp(r"'(\w+)':\s*DttFieldMeta\(\s*type:\s*'([^']+)'");

  for (final match in fieldPattern.allMatches(content)) {
    fields[match.group(1)!] = match.group(2)!;
  }

  return fields;
}

String _generateBlocCode(
  String className,
  Map<String, String> fields,
  String originalFileName,
) {
  final buffer = StringBuffer();
  final blocClassName = 'DttBloc$className';

  // Add file header
  buffer.writeln('// GENERATED BY DARTANTIC BLOC GENERATOR');
  buffer.writeln();
  buffer.writeln("part of '$originalFileName.dart';");
  buffer.writeln();

  // Generate state classes
  buffer.writeln('abstract class ${blocClassName}State extends Equatable {');
  buffer.writeln('  const ${blocClassName}State();');
  buffer.writeln('  @override');
  buffer.writeln('  List<Object?> get props => [];');
  buffer.writeln();
  buffer.writeln(
    '  static ${blocClassName}State initial() => const ${blocClassName}Initial();',
  );
  buffer.writeln(
    '  static ${blocClassName}State loading() => const ${blocClassName}Loading();',
  );
  buffer.writeln(
    '  static ${blocClassName}State error(String message) => ${blocClassName}Error(message);',
  );
  buffer.writeln(
    '  static ${blocClassName}State success(${blocClassName}StateData data) => data;',
  );
  buffer.writeln('}');
  buffer.writeln();

  // Generate state data class
  buffer.writeln(
    'class ${blocClassName}StateData extends ${blocClassName}State {',
  );

  // Fields
  for (final field in fields.entries) {
    buffer.writeln('  final ${field.value} ${field.key};');
  }

  // Constructor
  buffer.writeln('  const ${blocClassName}StateData({');
  for (final field in fields.entries) {
    final isRequired = !field.value.endsWith('?');
    buffer.writeln('    ${isRequired ? 'required ' : ''}this.${field.key},');
  }
  buffer.writeln('  });');

  // fromMap
  buffer.writeln(
    '  factory ${blocClassName}StateData.fromMap(Map<String, dynamic> map) {',
  );
  buffer.writeln('    return ${blocClassName}StateData(');
  for (final field in fields.entries) {
    buffer.writeln(
      '      ${field.key}: map[\'${field.key}\'] as ${field.value},',
    );
  }
  buffer.writeln('    );');
  buffer.writeln('  }');

  // toMap
  buffer.writeln('  Map<String, dynamic> toMap() => {');
  for (final field in fields.entries) {
    buffer.writeln('    \'${field.key}\': ${field.key},');
  }
  buffer.writeln('  };');

  // copyWith
  buffer.writeln('  ${blocClassName}StateData copyWith({');
  for (final field in fields.entries) {
    final type = field.value.endsWith('?') ? field.value : '${field.value}?';
    buffer.writeln('    $type ${field.key},');
  }
  buffer.writeln('  }) => ${blocClassName}StateData(');
  for (final field in fields.entries) {
    buffer.writeln('    ${field.key}: ${field.key} ?? this.${field.key},');
  }
  buffer.writeln('  );');

  // props
  buffer.writeln('  @override');
  buffer.writeln('  List<Object?> get props => [');
  for (final field in fields.entries) {
    buffer.writeln('    ${field.key},');
  }
  buffer.writeln('  ];');

  buffer.writeln('}');
  buffer.writeln();

  // Generate other state classes
  buffer.writeln(
    'class ${blocClassName}Loading extends ${blocClassName}State {',
  );
  buffer.writeln('  const ${blocClassName}Loading();');
  buffer.writeln('}');
  buffer.writeln();

  buffer.writeln('class ${blocClassName}Error extends ${blocClassName}State {');
  buffer.writeln('  final String message;');
  buffer.writeln('  const ${blocClassName}Error(this.message);');
  buffer.writeln('  @override');
  buffer.writeln('  List<Object?> get props => [message];');
  buffer.writeln('}');
  buffer.writeln();

  buffer.writeln(
    'class ${blocClassName}Initial extends ${blocClassName}State {',
  );
  buffer.writeln('  const ${blocClassName}Initial();');
  buffer.writeln('}');
  buffer.writeln();

  // Generate event classes
  buffer.writeln('abstract class ${blocClassName}Event extends Equatable {');
  buffer.writeln('  const ${blocClassName}Event();');
  buffer.writeln('  @override');
  buffer.writeln('  List<Object?> get props => [];');
  buffer.writeln('}');
  buffer.writeln();

  // Generate update events
  for (final field in fields.entries) {
    final eventName =
        '${blocClassName}Update${field.key[0].toUpperCase()}${field.key.substring(1)}';
    buffer.writeln('class $eventName extends ${blocClassName}Event {');
    buffer.writeln('  final ${field.value} ${field.key};');
    buffer.writeln('  const $eventName(this.${field.key});');
    buffer.writeln('  @override');
    buffer.writeln('  List<Object?> get props => [${field.key}];');
    buffer.writeln('}');
    buffer.writeln();
  }

  // Generate standard events
  buffer.writeln('class ${blocClassName}Load extends ${blocClassName}Event {');
  buffer.writeln('  const ${blocClassName}Load();');
  buffer.writeln('}');
  buffer.writeln();

  buffer.writeln('class ${blocClassName}Save extends ${blocClassName}Event {');
  buffer.writeln('  const ${blocClassName}Save();');
  buffer.writeln('}');
  buffer.writeln();

  buffer.writeln('class ${blocClassName}Reset extends ${blocClassName}Event {');
  buffer.writeln('  const ${blocClassName}Reset();');
  buffer.writeln('}');
  buffer.writeln();

  buffer.writeln(
    'class ${blocClassName}Validate extends ${blocClassName}Event {',
  );
  buffer.writeln('  const ${blocClassName}Validate();');
  buffer.writeln('}');
  buffer.writeln();

  // Generate cubit class
  buffer.writeln(
    'class ${blocClassName}Cubit extends Cubit<${blocClassName}State> {',
  );
  buffer.writeln(
    '  ${blocClassName}Cubit() : super(${blocClassName}State.initial());',
  );
  buffer.writeln();

  // Generate update methods
  for (final field in fields.entries) {
    final methodName =
        'update${field.key[0].toUpperCase()}${field.key.substring(1)}';
    buffer.writeln('  void $methodName(${field.value} ${field.key}) {');
    buffer.writeln('    if (isClosed) return;');
    buffer.writeln('    if (state is ${blocClassName}StateData) {');
    buffer.writeln(
      '      final currentState = state as ${blocClassName}StateData;',
    );
    if (field.key == 'name') {
      buffer.writeln(
        '      final processedName = ${className}._dttpreprocess_name(${field.key});',
      );
      buffer.writeln(
        '      emit(currentState.copyWith(${field.key}: processedName));',
      );
    } else if (field.key == 'age') {
      buffer.writeln(
        '      if (!${className}._dttvalidate_age(${field.key})) {',
      );
      buffer.writeln(
        '        emit(${blocClassName}State.error(\'Invalid age: ${field.key}\'));',
      );
      buffer.writeln('        return;');
      buffer.writeln('      }');
      buffer.writeln(
        '      emit(currentState.copyWith(${field.key}: ${field.key}));',
      );
    } else {
      buffer.writeln(
        '      emit(currentState.copyWith(${field.key}: ${field.key}));',
      );
    }
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();
  }

  // Generate load data method
  buffer.writeln('  Future<void> loadData(Map<String, dynamic> data) async {');
  buffer.writeln('    if (isClosed) return;');
  buffer.writeln('    emit(${blocClassName}State.loading());');
  buffer.writeln('    try {');
  buffer.writeln(
    '      final stateData = ${blocClassName}StateData.fromMap(data);',
  );
  buffer.writeln('      if (!${className}._dttvalidate_age(stateData.age)) {');
  buffer.writeln(
    '        emit(${blocClassName}State.error(\'Invalid age: \${stateData.age}\'));',
  );
  buffer.writeln('        return;');
  buffer.writeln('      }');
  buffer.writeln('      emit(stateData);');
  buffer.writeln('    } catch (e) {');
  buffer.writeln('      emit(${blocClassName}State.error(e.toString()));');
  buffer.writeln('    }');
  buffer.writeln('  }');
  buffer.writeln();

  // Generate save data method
  buffer.writeln('  Future<void> saveData() async {');
  buffer.writeln('    if (isClosed) return;');
  buffer.writeln('    if (state is! ${blocClassName}StateData) return;');
  buffer.writeln('    emit(${blocClassName}State.loading());');
  buffer.writeln('    try {');
  buffer.writeln(
    '      final currentState = state as ${blocClassName}StateData;',
  );
  buffer.writeln('      if (!validate()) {');
  buffer.writeln(
    '        emit(${blocClassName}State.error(\'Validation failed\'));',
  );
  buffer.writeln('        return;');
  buffer.writeln('      }');
  buffer.writeln('      // TODO: Implement actual save logic');
  buffer.writeln('      emit(currentState);');
  buffer.writeln('    } catch (e) {');
  buffer.writeln('      emit(${blocClassName}State.error(e.toString()));');
  buffer.writeln('    }');
  buffer.writeln('  }');
  buffer.writeln();

  // Generate reset method
  buffer.writeln('  void reset() {');
  buffer.writeln('    if (isClosed) return;');
  buffer.writeln('    emit(${blocClassName}State.initial());');
  buffer.writeln('  }');
  buffer.writeln();

  // Generate validate method
  buffer.writeln('  bool validate() {');
  buffer.writeln('    if (state is! ${blocClassName}StateData) return false;');
  buffer.writeln('    final data = state as ${blocClassName}StateData;');
  buffer.writeln('    return ${className}._dttvalidate_age(data.age);');
  buffer.writeln('  }');
  buffer.writeln();

  buffer.writeln('}');

  return buffer.toString();
}
