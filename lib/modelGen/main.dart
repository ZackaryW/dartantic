import 'dart:async';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'annotations/annotations.dart';
import 'package:analyzer/dart/element/element.dart';

// Import modular generators
import 'generators/create_method.dart';
import 'generators/preprocess_method.dart';
import 'generators/validate_method.dart';
import 'generators/postprocess_method.dart';
import 'generators/frommap_method.dart';
import 'generators/tomap_method.dart';
import 'generators/metadata.dart';

// Import utilities
import 'utils/field_utils.dart';

class ModelGenerator extends GeneratorForAnnotation<DttModel> {
  static final Map<String, ClassElement> _modelClasses = {};

  @override
  Future<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        '`@DttModel()` can only be applied to classes.',
        element: element,
      );
    }

    // First pass: collect all model classes
    _modelClasses[element.name] = element;

    // Generate the field metadata dictionary
    final fieldMetaDict = FieldUtils.generateFieldMetaDict(
      element,
      _modelClasses,
    );

    // Generate all method sources using modular generators
    final methodSources = [
      CreateMethodGenerator.generate(element, fieldMetaDict).source,
      PreprocessMethodGenerator.generate(element, fieldMetaDict).source,
      ValidateMethodGenerator.generate(element, fieldMetaDict).source,
      PostprocessMethodGenerator.generate(element, fieldMetaDict).source,
      FromMapMethodGenerator.generate(element, fieldMetaDict).source,
      ToMapMethodGenerator.generate(element, fieldMetaDict).source,
    ];

    // Generate both metadata and mixin
    final metaCode = MetadataGenerator.generateModelMetaCode(
      element.name,
      fieldMetaDict,
    );
    final mixinCode = MetadataGenerator.generateClassMixin(
      element.name,
      methodSources,
    );

    return '$metaCode\n\n$mixinCode';
  }
}

Builder modelGeneratorBuilder(BuilderOptions options) => PartBuilder(
  [ModelGenerator()],
  '.dartantic.g.dart',
  header: '// GENERATED BY DARTANTIC\n',
);
